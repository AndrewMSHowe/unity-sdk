<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>CotC SDK Unity: Working with matches</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CotC SDK Unity
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Working with matches </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Clan of the Cloud provides a simple way to run matches between a set of gamers using the network. The match system is designed around a centralized game state stored on the Clan of the Cloud servers, with gamers participating to the match making a move, updating the global game state and notifying the other players on an asynchronous basis.</p>
<p>It means that this match system is better suited for turn by turn games, rather than real time games such as MMORPGs, which may require a more sophisticated logic to be handled on your servers.</p>
<p>As with other functionality, matches are scoped by domain, allowing to share data amongst multiple games. By default, your game has one dedicated domain called <code>private</code>, which you should use unless you need cross-game functionality.</p>
<h2>API basics </h2>
<p>The match manager is exposed through the <a class="el" href="class_cotc_sdk_1_1_gamer_matches.html">CotcSdk.GamerMatches</a> objects which is obtained through an instance of <a class="el" href="class_cotc_sdk_1_1_gamer.html">CotcSdk.Gamer</a>. This class exposes what is required to create or join a match, as well as managing invitations by other players. Once a match is started, joined or resumed, an instance of <a class="el" href="class_cotc_sdk_1_1_match.html">CotcSdk.Match</a> is received and can be used to perform various operations on the ongoing match.</p>
<p>An example of match with two players logged in locally (which usually do not happen as they will be on separate machines) is shown below:</p>
<div class="fragment"><div class="line">Cloud.LoginAnonymously().Done((Gamer gamer1) =&gt; {</div>
<div class="line">    Cloud.LoginAnonymously().Done((Gamer gamer2) =&gt; {</div>
<div class="line">        <span class="comment">// Loops are needed in order to catch events (OnMovePosted below)</span></div>
<div class="line">        gamer1.StartEventLoop();</div>
<div class="line">        gamer2.StartEventLoop();</div>
<div class="line"></div>
<div class="line">        gamer1.Matches.Create(maxPlayers: 2).Done((Match matchP1) =&gt; {</div>
<div class="line">            <span class="comment">// We have the match object which can be used to post moves and so on</span></div>
<div class="line">            <span class="comment">// Subscribe to an event</span></div>
<div class="line">            matchP1.OnMovePosted += (Match sender, MatchMoveEvent e) =&gt; {</div>
<div class="line">                Debug.Log(e.PlayerId + <span class="stringliteral">&quot; played at &quot;</span> + e.MoveData[<span class="stringliteral">&quot;position&quot;</span>]);</div>
<div class="line">                <span class="comment">// Finish the match</span></div>
<div class="line">                matchP1.Finish();</div>
<div class="line">            };</div>
<div class="line"></div>
<div class="line">            gamer2.Matches.Join(matchP1.MatchId).Done((Match matchP2) =&gt; {</div>
<div class="line">                <span class="comment">// Same now for P2. Post a move which will be caught by P1.</span></div>
<div class="line">                matchP2.PostMove(Bundle.CreateObject(<span class="stringliteral">&quot;position&quot;</span>, 10));</div>
<div class="line">            });</div>
<div class="line">        });</div>
<div class="line">    });</div>
<div class="line">});</div>
</div><!-- fragment --><h2>Creating and listing matches </h2>
<p>Creating a match is done by calling <a class="el" href="class_cotc_sdk_1_1_gamer_matches.html#ad240e59b87eb919fb808be0c9e1dc663">CotcSdk.GamerMatches.Create</a>. It will result in a <a class="el" href="class_cotc_sdk_1_1_match.html">CotcSdk.Match</a> object that you can keep for use later. The following two snippets show how to do it:</p>
<div class="fragment"><div class="line">gamer.Matches.Domain(<span class="stringliteral">&quot;private&quot;</span>).Create(</div>
<div class="line">    maxPlayers: 10,</div>
<div class="line">    description: <span class="stringliteral">&quot;My match&quot;</span>,</div>
<div class="line">    customProperties: Bundle.CreateObject(<span class="stringliteral">&quot;gameType&quot;</span>, <span class="stringliteral">&quot;solo&quot;</span>))</div>
<div class="line">.Then(createdMatch =&gt; {</div>
<div class="line">    Debug.Log(<span class="stringliteral">&quot;Match with ID &quot;</span> + createdMatch.MatchId + <span class="stringliteral">&quot; created!&quot;</span>);</div>
<div class="line">})</div>
<div class="line">.Catch(ex =&gt; Debug.LogError(<span class="stringliteral">&quot;Failed to create match: &quot;</span> + ex.ToString()));</div>
</div><!-- fragment --><p>Match objects do not need any special lifecycle management. They simply keep a local copy of the match state for easy querying, and provide the necessary methods to interact with the match in its current state. If you drop a reference to a Match object, nothing will happen. You may even have several of them referring to the same match.</p>
<p>Once your game is created, you will want other players to join it, and <a class="el" href="class_cotc_sdk_1_1_gamer_matches.html#a17a58535c1568e0b89116a1656b2d16c">CotcSdk.GamerMatches.List</a> is here for that. As described previously, your game has a dedicated domain. On this domain, any player is able to create matches. This means that there are potentially millions of matches scoped to your domain. In order to refine the potential matches that one may want to display, conditions can be specified as parameters. By default, a number of conditions will hide some matches from the list. These include the maximum number of players having been reached or the match being in finished state.</p>
<p>In order to refine the searches, you are encouraged to use indexing. Let's say that your match has an attribute "type", which determines what type of game it is (coop, versus, capture the flag, etc.), and you would like to find all matches from a given type. The solution is to index a match whenever it is created in an index named for instance "matches", with the object ID being the match ID and indexed properties being for instance the type. This should mostly be done on the server by using hooks (<code>after-match-create</code>) and so on, but you may as well do it on the client.</p>
<div class="fragment"><div class="line">gamer.Matches.Create(maxPlayers: 16)</div>
<div class="line">.Then(match =&gt; {</div>
<div class="line">    Bundle matchProps = Bundle.CreateObject(<span class="stringliteral">&quot;type&quot;</span>, <span class="stringliteral">&quot;coop&quot;</span>, <span class="stringliteral">&quot;owner_id&quot;</span>, gamer.GamerId);</div>
<div class="line">    <span class="comment">// Index the match</span></div>
<div class="line">    <span class="keywordflow">return</span> cloud.Index(<span class="stringliteral">&quot;matches&quot;</span>).IndexObject(match.MatchId, matchProps, Bundle.Empty);</div>
<div class="line">})</div>
<div class="line">.Then(indexResult =&gt; {</div>
<div class="line">    <span class="comment">// Match indexed, now look it up</span></div>
<div class="line">    <span class="keywordtype">string</span> queryStr = <span class="stringliteral">&quot;type:coop AND owner_id:&quot;</span> + gamer.GamerId;</div>
<div class="line">    <span class="keywordflow">return</span> cloud.Index(<span class="stringliteral">&quot;matches&quot;</span>).Search(queryStr);</div>
<div class="line">})</div>
<div class="line">.Then(foundMatches =&gt; {</div>
<div class="line">    Debug.Log(<span class="stringliteral">&quot;Matches: &quot;</span> + foundMatches.Hits.Count);</div>
<div class="line">})</div>
<div class="line">.Catch(ex =&gt; {...});</div>
</div><!-- fragment --><p>In that case, if the properties of the match change, you will need to reindex it. That is why it is much safer and simpler to do it on the server using hooks (i.e. <code>after-match-create</code>, <code>after-match-join</code>, etc.).</p>
<h2>The lifecycle of a match </h2>
<p>A match is created by a player which is called <code>creator</code>. A <code>creator</code> is solely able to perform some administrative functions, such as deleting or finishing a match. When creating a match, you automatically become a player (although you are able to leave it right away). Everyone is free to join the match, and leave it anytime. A notification is sent to every player whenever that happens.</p>
<p>When the match is considered complete, the <code>creator</code> should mark it finished by calling <a class="el" href="class_cotc_sdk_1_1_match.html#aa7bb24b19c0f12fb9e961419ccf215dd">CotcSdk.Match.Finish</a>. He may optionally delete it once finshed successfully. Finished matches are not listed by default and all calls interacting with them do fail.</p>
<h2>Match notifications </h2>
<p>Match notifications (aKa events) are broadcasted on the domain corresponding to the match being run. Any player who has joined the match will automatically receive events indicating changes made to the match. These events happen when a player joins the match, leaves it or posts a move.</p>
<p>These events must be processed by each player prior to issuing additional commands. The class <a class="el" href="class_cotc_sdk_1_1_match.html">CotcSdk.Match</a> takes care of this internally by catching them via a <a class="el" href="class_cotc_sdk_1_1_domain_event_loop.html">CotcSdk.DomainEventLoop</a>. Therefore, you need to start one for the domain your match is running on prior to subscribing to any event or starting/joining/resuming a match. A warning will be issued in the console should you forget to do so, so keep an eye on it.</p>
<p>In a match played properly, a player should only make a move when it is his turn to do so. This should be evaluated by deterministic game rules, in order to avoid situations where two players may make a move at the same time, leading to race conditions. And you should only allow to perform a move to a given player when the the player whose turn was previous has played (subscribe to #CotcSdk.Match.OnMovePosted). Race conditions are detected by CotC and will lead to an exception as shown in the snippet below.</p>
<div class="fragment"><div class="line">match.PostMove(...)</div>
<div class="line">.Then(dummy =&gt; {...})</div>
<div class="line">.Catch(ex =&gt; {</div>
<div class="line">    <span class="keywordflow">if</span> (ex.ServerData[<span class="stringliteral">&quot;name&quot;</span>] == <span class="stringliteral">&quot;InvalidLastEventId&quot;</span>) {</div>
<div class="line">        <span class="comment">// There was a synchronization problem</span></div>
<div class="line">    }</div>
<div class="line">});</div>
</div><!-- fragment --><p>In order to improve race condition detection, you may ensure that no event is emitted during the preparation of your next API request by using <a class="el" href="class_cotc_sdk_1_1_match.html#ab201d6d0ab0da32d9812c95a110c596f">CotcSdk.Match.Lock</a>. This will defer any event that may modify the state of the match. It can be useful in cases where the following scenario is possible:</p>
<ul>
<li>Let M be a match with players P1 and P2. A player P1 can only attack another player P2 if both are still playing.</li>
<li>P1 wants to attack P2 and prepares a <code>PostMove</code> call for this.</li>
<li>P2 leaves the match and the event is received by P1.</li>
<li>P1 posts its move.</li>
</ul>
<p>In this case, unless you use a <code>Lock</code> block, the SDK will think that you handled the fact that P2 has left properly and let your request succeed. Wrapping the preparation of the move along with the <code>PostMove</code> call in a <code>Lock</code> block will ensure that the leave event is triggered later, triggering a race condition exception as intended when P1 posts his move.</p>
<div class="fragment"><div class="line">match.Lock(() =&gt; {</div>
<div class="line">    <span class="comment">// Condition in order for P1 to be able to play</span></div>
<div class="line">    <span class="keywordflow">if</span> (match.Players.Count == 2) {</div>
<div class="line">        Bundle move = Bundle.CreateObject(<span class="stringliteral">&quot;x&quot;</span>, 1);</div>
<div class="line">        match.PostMove(move)</div>
<div class="line">        .Catch(ex =&gt; {</div>
<div class="line">            if (ex.ServerData[<span class="stringliteral">&quot;name&quot;</span>] == <span class="stringliteral">&quot;InvalidLastEventId&quot;</span>) { ... }</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line">});</div>
</div><!-- fragment --><p>In case a player joins the match, the following event will be received by other players. You can subscribe to it at a higher level by using the #Cotc.Match.OnPlayerJoined event.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    <span class="stringliteral">&quot;event&quot;</span>: {</div>
<div class="line">        <span class="stringliteral">&quot;_id&quot;</span>: <span class="stringliteral">&quot;548866edba0ec600005e1941&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;match_id&quot;</span>: <span class="stringliteral">&quot;548866ed74c2e0000098db95&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;playersJoined&quot;</span>: [</div>
<div class="line">            {</div>
<div class="line">                <span class="stringliteral">&quot;gamer_id&quot;</span>: <span class="stringliteral">&quot;548866ed74c2e0000098db94&quot;</span>,</div>
<div class="line">                <span class="stringliteral">&quot;profile&quot;</span>: {</div>
<div class="line">                    <span class="stringliteral">&quot;displayName&quot;</span>: <span class="stringliteral">&quot;Guest&quot;</span>,</div>
<div class="line">                    <span class="stringliteral">&quot;lang&quot;</span>: <span class="stringliteral">&quot;en&quot;</span></div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        ]</div>
<div class="line">    },</div>
<div class="line">    <span class="stringliteral">&quot;id&quot;</span>: <span class="stringliteral">&quot;9155987d-6322-46d4-9403-e90ab4ba5fa3&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;type&quot;</span>: <span class="stringliteral">&quot;match.join&quot;</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>In case a player leaves the match, similarly the following event will be received by others. You can subscribe to it at a higher level by using the #Cotc.Match.OnPlayerLeft event.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    <span class="stringliteral">&quot;event&quot;</span>: {</div>
<div class="line">        <span class="stringliteral">&quot;_id&quot;</span>: <span class="stringliteral">&quot;548866eeba0ec600005e1948&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;match_id&quot;</span>: <span class="stringliteral">&quot;548866ed74c2e0000098db95&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;playersLeft&quot;</span>: [</div>
<div class="line">            {</div>
<div class="line">                <span class="stringliteral">&quot;gamer_id&quot;</span>: <span class="stringliteral">&quot;548866ed74c2e0000098db94&quot;</span>,</div>
<div class="line">                <span class="stringliteral">&quot;profile&quot;</span>: {</div>
<div class="line">                    <span class="stringliteral">&quot;displayName&quot;</span>: <span class="stringliteral">&quot;Guest&quot;</span>,</div>
<div class="line">                    <span class="stringliteral">&quot;lang&quot;</span>: <span class="stringliteral">&quot;en&quot;</span></div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        ]</div>
<div class="line">    },</div>
<div class="line">    <span class="stringliteral">&quot;id&quot;</span>: <span class="stringliteral">&quot;5007fd0a-1365-4e87-aba8-5d916731e684&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;type&quot;</span>: <span class="stringliteral">&quot;match.leave&quot;</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>In case the match is marked as finished, the following event will be broadcasted to all players except the one who initiated it. You can subscribe to it at a higher level by using the #Cotc.Match.OnMatchFinished event.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    <span class="stringliteral">&quot;type&quot;</span>: <span class="stringliteral">&quot;match.finish&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;event&quot;</span>: {</div>
<div class="line">        <span class="stringliteral">&quot;_id&quot;</span>: <span class="stringliteral">&quot;54784d07a0fcf2000086457d&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;finished&quot;</span>: 1,</div>
<div class="line">        <span class="stringliteral">&quot;match_id&quot;</span>: <span class="stringliteral">&quot;54784d07f10c190000cb96e3&quot;</span></div>
<div class="line">    },</div>
<div class="line">    <span class="stringliteral">&quot;id&quot;</span>: <span class="stringliteral">&quot;d2f908d1-40d8-4f73-802e-fe0086bb6cd5&quot;</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>In case a move was posted, an event like the following one is fired. You can subscribe to it at a higher level by using the #Cotc.Match.OnShoeDrawn event.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    <span class="stringliteral">&quot;type&quot;</span>: <span class="stringliteral">&quot;match.move&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;event&quot;</span>: {</div>
<div class="line">        <span class="stringliteral">&quot;_id&quot;</span>: <span class="stringliteral">&quot;54784176a8df72000049340e&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;player_id&quot;</span>: <span class="stringliteral">&quot;547841755e4cfe0000bf6907&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;move&quot;</span>: {</div>
<div class="line">            <span class="stringliteral">&quot;what&quot;</span>: <span class="stringliteral">&quot;changed&quot;</span></div>
<div class="line">        }</div>
<div class="line">    },</div>
<div class="line">    <span class="stringliteral">&quot;id&quot;</span>: <span class="stringliteral">&quot;d0fb71c1-3cd0-4bbd-a9ec-29cb46cf9203&quot;</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>In case an element was drawn from the shoe, an event like this is fired. You can subscribe to it at a higher level by using the #Cotc.Match.OnMovePosted event.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    <span class="stringliteral">&quot;type&quot;</span>: <span class="stringliteral">&quot;match.shoedraw&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;event&quot;</span>: {</div>
<div class="line">        <span class="stringliteral">&quot;_id&quot;</span>: <span class="stringliteral">&quot;5492a7c7a6725f0000b59e4f&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;count&quot;</span>: 2,</div>
<div class="line">        <span class="stringliteral">&quot;match_id&quot;</span>: <span class="stringliteral">&quot;5492a7c6a6725f0000b59e46&quot;</span></div>
<div class="line">    },</div>
<div class="line">    <span class="stringliteral">&quot;id&quot;</span>: <span class="stringliteral">&quot;5e4e82c1-d728-4a4b-be40-e4abec320440&quot;</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2>Synchronizing progress amongst players </h2>
<p>Aside from spontaneous events (player joins, leaves, etc.), matches are made up of moves, which act as checkpoints for each "measurable step" in the game. A move is performed anytime by a player (the game logic should determine who has its turn each time), and is made up of two parameters:</p><ul>
<li>moveData: a freeform JSON that describes what happened. In the case of a chess game, it could contain "moved knight to B3".</li>
<li>updatedGameState: an optional freeform JSON that can be updated incrementally (i.e. only present attributes are affected, others are left untouched) and can contain the global state of the game. In the case of a chess game, it could contain the game piece matrix. Passing a global state will clear the history of events.</li>
</ul>
<p>All events (move, join, etc.) are kept in the history of the match and will be passed along when fetching information about an individual match. This history can be used to reproduce the state of the game, by starting up clean and performing the pending moves locally. This allows to resume a match or simply join it anytime.</p>
<p>A global state is to be passed when you have a simple and concise way to describe the game field. If you do not pass a global state, individual events will be kept in the history of the match which might become too big at some point, depending on your game.</p>
<p>Therefore, you do not need to pass a global state with each move: it should be used to avoid messing up the history and if your game can support it. You need to pick an appropriate policy according to your game (maximum number of moves, checkpoints in-between, etc.).</p>
<h2>Private matches and invitations </h2>
<p>Matches can not be made private directly, but you can use the indexing as shown previously to add an attribute that exclude them from public listing (such as {"visibility": "public"}) and include this property in the filter when listing the public matches.</p>
<p>Once a player has created a given match, he can then invite other players he would like to join by sending an invitation. Of course, you should not send more invitations than the number of vacant players in the match (it is allowed but will produce an error if more players than allowed join).</p>
<div class="fragment"><div class="line">gamer.Matches.OnMatchInvitation += (MatchInviteEvent e) =&gt; {</div>
<div class="line">    Debug.Log(<span class="stringliteral">&quot;Invited by &quot;</span> + e.Inviter.GamerId + <span class="stringliteral">&quot; to match &quot;</span> + e.Match.MatchId);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">match.InvitePlayer(gamer.GamerId);</div>
</div><!-- fragment --><p>The list of pending invitations can be shown by using <a class="el" href="class_cotc_sdk_1_1_gamer_matches.html#a17a58535c1568e0b89116a1656b2d16c">CotcSdk.GamerMatches.List</a> and setting <code>invited</code> to true. An invitation is cleared when the player joins the match or by calling <a class="el" href="class_cotc_sdk_1_1_match_info.html#a78a23e3234ff3f384f0952e9167a2a02">CotcSdk.MatchInfo.DismissInvitation</a>.</p>
<h2>Random-generator based games (Casino "shoe"-like functionality) </h2>
<p>CloudBuilder provides functionality to help building games of chance, allowing each individual players to check the outcome of the match in order to ensure consistency. It does this by providing a server-based randomizing device, which hides sensitive information. Therefore, it can help ensure that all players, including the match creator have the same chances. And that no one is able to predict the outcome of the match (or fiddle/hack with it either, as other players are able to detect it).</p>
<p>The seed element that is returned with the detailed version of the match (i.e. when joining or fetching it), along with the shoe are the two elements which help building games of chance. The seed is a random number that is generated upon creation of every match. It can be used to initialize a pseudorandom number generator inside the game, and allows to ensure that every player will thus have the same sequence of values.</p>
<p>The shoe, as in Casino, is basically a container of possible values that are returned in a random order as they are poked. It could represent the values of the cards for instance. It is possible to have more than once the same element in the shoe (as when having two card sets). The shoe is posted by the person who creates the game and then shuffled. The shoe remains hidden, with no one having access to it, until the match is finished.</p>
<p>Players can draw one or more elements off the shoe by posting a request to this resource. The shoe is shared with all players, meaning that any element from the shoe is returned only once to a player having requested it. When all items have been drawn from the shoe and more items are requested, the existing serie is duplicated, shuffled and appended to the current shoe, meaning an endless play can be considered. Drawing items from the shoe will trigger one event of type <a class="el" href="class_cotc_sdk_1_1_match_shoe_drawn_event.html">CotcSdk.MatchShoeDrawnEvent</a> per request, sent to players except the caller. When the match finishes, fetching detailed info about the match will return the shoe. It can be used by all players to check that the game has been fair: should one player have hacked the game, it is possible to detect it by comparing the shoe to the actual moves.</p>
<p>To use the shoe in your match, the match creator must post an array of values in the configuration JSON. These values may be any object, from a simple number to an object with a complex hierarchy. We suggest using values as simple as possible though, to spare bandwidth when drawing items from the shoe. An example is shown below.</p>
<div class="fragment"><div class="line">gamer.Matches.Create(</div>
<div class="line">    maxPlayers: 10,</div>
<div class="line">    shoe: Bundle.CreateArray(1, 2, 3))</div>
<div class="line">.Done(match =&gt; {...});</div>
</div><!-- fragment --><p>Drawing objects can be done this way:</p>
<div class="fragment"><div class="line">match.DrawFromShoe(count: 1)</div>
<div class="line">.Done((DrawnItemsResult result) =&gt; {</div>
<div class="line">    Debug.Log(<span class="stringliteral">&quot;Item drawn: &quot;</span> + (<span class="keywordtype">int</span>)result.Items[0]);</div>
<div class="line">});</div>
</div><!-- fragment --><p>When the game is finished, anyone is able check the contents of the shoe by using <a class="el" href="class_cotc_sdk_1_1_gamer_matches.html#a89afde906b959dbeef05e12b828cad7e">CotcSdk.GamerMatches.Fetch</a> and inspecting the <code>shoe</code> subnode of the <code>match</code> node present in the result. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Aug 4 2015 08:32:37 for CotC SDK Unity by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
