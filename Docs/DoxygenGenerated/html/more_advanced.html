<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>CloudBuilder Unity: More advanced topics</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CloudBuilder Unity
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">More advanced topics </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Using CHJSON </h1>
<p>In the CloudBuilder SDK, most of the API calls are configurable through a JSON entity called <code>CHJSON</code>, which behaves as a dictionary like a JSON object. Here is an example:</p>
<div class="fragment"><div class="line">CotCHelpers::CHJSON json;</div>
<div class="line">json.Put(<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;value&quot;</span>);</div>
<div class="line"></div>
<div class="line">CotCHelpers::CHJSON subObject;</div>
<div class="line">subObject.Put(<span class="stringliteral">&quot;hasValue&quot;</span>, <span class="keyword">true</span>);</div>
<div class="line">json.Put(<span class="stringliteral">&quot;object&quot;</span>, subObject);</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *result = json.print();</div>
<div class="line"><span class="comment">// Results in {&quot;key&quot;: &quot;value&quot;, &quot;object&quot;: {&quot;hasValue&quot;: true}}</span></div>
<div class="line">free(result);</div>
</div><!-- fragment --><p>To write your CHJSON objects, the following methods are recommended:</p>
<p><code>void CotCHelpers::CHJSON::Clear()</code><br />
 <code>void CotCHelpers::CHJSON::Delete(const char *aItem)</code><br />
 <code>CHJSON* CotCHelpers::CHJSON::Duplicate() const</code><br />
 <code>const CHJSON* CotCHelpers::CHJSON::Empty()</code><br />
 <code>void CotCHelpers::CHJSON::Put(const char *aKey, bool aValue)</code><br />
 <code>void CotCHelpers::CHJSON::Put(const char *aKey, int aValue)</code><br />
 <code>void CotCHelpers::CHJSON::Put(const char *aKey, double aValue)</code><br />
 <code>void CotCHelpers::CHJSON::Put(const char *aKey, const char *aValue)</code><br />
 <code>void CotCHelpers::CHJSON::Put(const char *aKey, CHJSON *aValue)</code><br />
 <code>void CotCHelpers::CHJSON::Put(const char *aKey, const CHJSON *aValue)</code><br />
 <code>void CotCHelpers::CHJSON::Put(const char *aKey, const CHJSON&amp; aValue)</code><br />
 <code>CHJSON* CotCHelpers::CHJSON::parse(const char *aJsonString)</code><br />
 <code>char* CotCHelpers::CHJSON::print() const</code><br />
 <code>char* CotCHelpers::CHJSON::printFormatted() const;</code></p>
<p>If performance is less a concern to you or if you want to do quick prototyping, you may as well use <code>CHJSON</code> objects by reference. In that case, do not forget to delete the object when not needed anymore. Note that when putting an non-const <code>CHJSON</code> object inside another however, ownership is transferred to the new container, so you do not need to delete it yourself. This enables constructs as shown below.</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>CotCHelpers;</div>
<div class="line">CHJSON *otherJson = <span class="keyword">new</span> CHJSON;</div>
<div class="line">otherJson-&gt;Put(<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;value&quot;</span>);</div>
<div class="line"></div>
<div class="line">CHJSON *json = <span class="keyword">new</span> CHJSON;</div>
<div class="line">json-&gt;Put(<span class="stringliteral">&quot;subObject&quot;</span>, otherJson);      <span class="comment">// ownership taken, no need to delete otherJson</span></div>
<div class="line"><span class="comment">// -- do not access otherJson from now, it has been rebased to json.subObject --</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Same here, the temporary object created by Parse is owned by json</span></div>
<div class="line">json-&gt;Put(<span class="stringliteral">&quot;otherObj&quot;</span>, CHJSON::parse(<span class="stringliteral">&quot;{\&quot;count\&quot;: 1}&quot;</span>));</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> CHJSON *value = json-&gt;Get(<span class="stringliteral">&quot;subObject&quot;</span>);</div>
<div class="line">json-&gt;Put(<span class="stringliteral">&quot;copy&quot;</span>, value);       <span class="comment">// copied, because the JSON is const</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Produces {&quot;subObject&quot;:{&quot;key&quot;:&quot;value&quot;},&quot;otherObj&quot;:{&quot;count&quot;:1},&quot;copy&quot;:{&quot;key&quot;:&quot;value&quot;}}</span></div>
<div class="line"><span class="keyword">delete</span> json;</div>
</div><!-- fragment --><h2>Arrays </h2>
<p>Arrays should not be needed, but you can create them like this:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>CotCHelpers;</div>
<div class="line">CHJSON *array = CHJSON::Array();</div>
<div class="line">CHJSON *objEntry = <span class="keyword">new</span> CHJSON;</div>
<div class="line">CHJSON *numericEntry = <span class="keyword">new</span> CHJSON(12.0);</div>
<div class="line">objEntry-&gt;Put(<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;value&quot;</span>);</div>
<div class="line">array-&gt;Add(objEntry);</div>
<div class="line">array-&gt;Add(numericEntry);</div>
<div class="line"><span class="comment">// Produces [{&quot;key&quot;: &quot;value&quot;}, 12]</span></div>
<div class="line"><span class="keyword">delete</span> array;</div>
</div><!-- fragment --><h2>Reading from CHJSON </h2>
<p><code>CHJSON</code> objects are also used when returning a value from the SDK. Most of the calls take a callback (CloudBuilder::CResultHandler) which has the following form.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyGame::ResultHandler(eErrorCode code, <span class="keyword">const</span> CCloudResult *result) {</div>
<div class="line">    <span class="keyword">const</span> CHJSON *json = result-&gt;GetJSON();</div>
<div class="line">}</div>
</div><!-- fragment --><p>This object is guaranteed never <code>NULL</code> (at worst it is empty). You can read from <code>CHJSON</code> objects in a safe and compact way using this recommended set of methods.</p>
<p><code>bool CotCHelpers::CHJSON::Has(const char *key) const</code><br />
 <code>const CHJSON* CotCHelpers::CHJSON::Get(int aIndex) const</code><br />
 <code>const CHJSON* CotCHelpers::CHJSON::Get(const char *aItem) const</code><br />
 <code>const CHJSON* CotCHelpers::CHJSON::GetSafe(int aIndex) const</code><br />
 <code>const CHJSON* CotCHelpers::CHJSON::GetSafe(const char *aItem) const</code><br />
 <code>double CotCHelpers::CHJSON::GetDouble(const char *aItem, double defaultValue) const</code><br />
 <code>int CotCHelpers::CHJSON::GetInt(const char *aItem, int defaultValue) const</code><br />
 <code>bool CotCHelpers::CHJSON::GetBool(const char *aItem, bool defaultValue) const</code><br />
 <code>const char* CotCHelpers::CHJSON::GetString(const char *key, const char *defaultValue) const</code><br />
 <code>Iterator CotCHelpers::CHJSON::begin() const</code><br />
 <code>Iterator CotCHelpers::CHJSON::end() const</code><br />
 <code>int CotCHelpers::CHJSON::size() const</code><br />
</p>
<p>If you expect to have an object such as {"obj": {"value": 123}} then you can safely do the following.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyGame::ResultHandler(eErrorCode code, <span class="keyword">const</span> CCloudResult *result) {</div>
<div class="line">    <span class="keyword">const</span> CHJSON *json = result-&gt;GetJSON();</div>
<div class="line">    <span class="keywordtype">int</span> value = json-&gt;GetSafe(<span class="stringliteral">&quot;obj&quot;</span>)-&gt;GetInt(<span class="stringliteral">&quot;value&quot;</span>);</div>
<div class="line">    <span class="comment">// Value will be either 0 (either json is empty, obj doesn&#39;t exist or value doesn&#39;t exist) either the desired value</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>It will work because all <code>Get*</code> methods (except CotCHelpers::CHJSON::Get itself which might return <code>NULL</code>) will safely handle the fact that the desired object does not exist and return a default value. In the case of CotCHelpers::CHJSON::GetSafe it is simply an empty object (see CotCHelpers::CHJSON::Empty) so you may transitively query for additional keys within the hierarchy without worrying.</p>
<p>Optionally, you can also pass a default value to the <code>Get*</code> methods, which will be returned in case the element is not found.</p>
<p>Listing the sub-nodes ("values") of a <code>CHJSON</code> can be done easily using the provided iterator.</p>
<div class="fragment"><div class="line">CHJSON *<span class="keywordtype">object</span> = <span class="keyword">new</span> CHJSON;</div>
<div class="line"><span class="keywordtype">object</span>-&gt;Put(<span class="stringliteral">&quot;key1&quot;</span>, <span class="stringliteral">&quot;value1&quot;</span>);</div>
<div class="line"><span class="keywordtype">object</span>-&gt;Put(<span class="stringliteral">&quot;key2&quot;</span>, <span class="stringliteral">&quot;value2&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> CHJSON *node: *<span class="keywordtype">object</span>) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *key = node-&gt;name();</div>
<div class="line">    printf(<span class="stringliteral">&quot;Key: %s, value: %s\n&quot;</span>, key, object-&gt;GetString(key));</div>
<div class="line">}</div>
<div class="line"><span class="keyword">delete</span> object;</div>
</div><!-- fragment --><p>This can be done for arrays as well, but nodes obviously won't have a name. This snippet is provided here for reference:</p>
<div class="fragment"><div class="line">CHJSON *array = CHJSON::Array();</div>
<div class="line">array-&gt;Add(<span class="keyword">new</span> CHJSON(123));</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> CHJSON *node: *array) {</div>
<div class="line">    <span class="keywordflow">if</span> (node-&gt;type() == CHJSON::jsonNumber)</div>
<div class="line">        printf(<span class="stringliteral">&quot;Got a number: %d&quot;</span>, node-&gt;valueInt());</div>
<div class="line">}</div>
</div><!-- fragment --><h1>Using callbacks (CResultHandler) </h1>
<p>The CloudBuilder SDK uses a strongly asynchronous programming model, with callbacks and listeners in many places to process data coming from the network. To achieve that, the model relies on a class named <code>CDelegate</code>, which basically allows to pass a pointer to a method with a given signature to be executed later when the arguments have become available. For reference, here is a sample of game requiring you to guess a number, with the method to check being passed as argument:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyGame {</div>
<div class="line">    <span class="keywordtype">void</span> Main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div>
<div class="line">        <span class="comment">// We&#39;ll accept the inputted number if it is odd, easy enough!</span></div>
<div class="line">        Play(MakeDelegate(<span class="keyword">this</span>, &amp;MyGame::IsOdd));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> Play(CDelegate&lt;<span class="keywordtype">bool</span> (<span class="keywordtype">int</span>)&gt; *checkFunc) {</div>
<div class="line">        <span class="keywordtype">int</span> inputtedNumber;</div>
<div class="line">        <span class="keywordflow">do</span> {</div>
<div class="line">            printf(<span class="stringliteral">&quot;Input a number: &quot;</span>);</div>
<div class="line">            scanf(<span class="stringliteral">&quot;%d&quot;</span>, &amp;inputtedNumber);</div>
<div class="line">        } <span class="keywordflow">while</span> (!checkFunc-&gt;Invoke(inputtedNumber));</div>
<div class="line">        <span class="keyword">delete</span> checkFunc;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> IsOdd(<span class="keywordtype">int</span> number) {</div>
<div class="line">        <span class="keywordflow">return</span> number % 2 == 0;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The same principle is used with <code>CResultHandler</code>, which is actually just a kind of <code>CDelegate</code> with standard arguments. Usually, you will want to create result handlers by using the provided MakeResultHandler method:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyGame::OnSetup(eErrorCode code, <span class="keyword">const</span> CCloudResult *result);</div>
<div class="line"></div>
<div class="line">CClan::Instance()-&gt;Setup(&amp;json, MakeResultHandler(<span class="keyword">this</span>, &amp;MyGame::OnSetup));</div>
</div><!-- fragment --><p>It will create the appropriate type of delegate using genericity, and the Setup method will not accept it if the type differ, meaning that you will have to fix the signature of your OnSetup method to match the expected one.</p>
<h2>Passing parameters </h2>
<p>The <code>MakeResultHandler</code> allows you to pass additional parameters, which will be forwarded to your method as additional arguments trailing the default ones. An example is shown below.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyGame::OnSetup(eErrorCode code, <span class="keyword">const</span> CCloudResult *result, <span class="keywordtype">int</span> additionalInt, <span class="keywordtype">char</span> *additionalStr) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Got %d and %s\n&quot;</span>, additionalInt, additionalStr);</div>
<div class="line">    free(additionalStr);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">CClan::Instance()-&gt;Setup(&amp;json, MakeResultHandler(<span class="keyword">this</span>, &amp;MyGame::OnSetup, 123, strdup(<span class="stringliteral">&quot;hello&quot;</span>)));</div>
</div><!-- fragment --><p>You can pass up to 3 parameters of any type, even a struct if you like. However, on a performance point of view, keep in mind that the parameters may be copied multiple times around, so it is peferrable to use either small and simple structures or pass a pointer. Also note that if you pass a pointer to something, it has to remain valid until the callback is called, so you will probably want to duplicate the object and delete it inside the callback as shown above with the strdup/free combo.</p>
<h2>Custom delegates </h2>
<p>Using polymorphism, it is also possible to make fully custom callbacks, which just have to respond to the specification of a <code>CDelegate</code> (that is, basically to provide an object/method combo corresponding to the signature, to be invoked). Anonymous structures come in handy for this task:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>SetupHandler: CResultHandler {</div>
<div class="line">    SetupHandler() : CResultHandler(this, &amp;SetupHandler::Done) {}</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> Done(eErrorCode code, <span class="keyword">const</span> CCloudResult *result) {</div>
<div class="line">        <span class="comment">// Inline (&quot;lambda&quot;-style) processing</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">CClan::Instance()-&gt;Setup(&amp;json, <span class="keyword">new</span> SetupHandler);</div>
</div><!-- fragment --><p>The only problem here is that your anonymous structure doesn't have access to the enclosed members. You need to capture them manually, as shown below for the <code>this</code> pointer.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyGame {</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> Main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div>
<div class="line">        <span class="keyword">struct </span>SetupHandler: CResultHandler {</div>
<div class="line">            MyGame *<span class="keyword">self</span>;</div>
<div class="line">            SetupHandler(MyGame *<span class="keyword">self</span>) : self(self), CResultHandler(this, &amp;SetupHandler::Done) {}</div>
<div class="line">            <span class="keywordtype">void</span> Done(eErrorCode code, <span class="keyword">const</span> CCloudResult *result) {</div>
<div class="line">                <span class="comment">// Inline (&quot;lambda&quot;-style) processing</span></div>
<div class="line">                <span class="keyword">self</span>-&gt;SetupOkay();</div>
<div class="line">            }</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        CClan::Instance()-&gt;Setup(&amp;json, <span class="keyword">new</span> SetupHandler(<span class="keyword">this</span>));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> SetupOkay() {</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>However, now that you know the inners of these delegates, you can forward the original call anywhere you like. You may for instance forward the call to a C++11 lambda as shown below, enabling for very nice constructs.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;functional&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> std::function&lt;void(eErrorCode, const CCloudResult*)&gt; resultHandler_t;</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> CResultHandler *MakeResultHandler(resultHandler_t func) {</div>
<div class="line">    <span class="keyword">struct </span>FunctionalResultHandler: CResultHandler {</div>
<div class="line">        resultHandler_t func;</div>
<div class="line">        FunctionalResultHandler(resultHandler_t func) : func(func), CResultHandler(this, &amp;FunctionalResultHandler::Done) {}</div>
<div class="line">        <span class="keywordtype">void</span> Done(eErrorCode code, <span class="keyword">const</span> CCloudResult *result) {</div>
<div class="line">            func(code, result);</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> FunctionalResultHandler(func);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>MyGame {</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> Main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div>
<div class="line"></div>
<div class="line">        CClan::Instance()-&gt;Setup(&amp;json, MakeResultHandler([=] (eErrorCode code, <span class="keyword">const</span> CCloudResult *result) {</div>
<div class="line">            this-&gt;SetupOkay();</div>
<div class="line">        }));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> SetupOkay() {</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>If you are using Visual C++ 2010, beware that there is a bug preventing nested lambdas from capturing the same member in this version. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jun 3 2015 10:46:19 for CloudBuilder Unity by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
