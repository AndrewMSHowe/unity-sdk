<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>CloudBuilder Unity: Getting started</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CloudBuilder Unity
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Getting started </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>We would like to thank you for downloading the CloudBuilder Client SDK and welcome you to the Clan! Through a few code samples, this guide will present you all the basics and help you quickly get started.</p>
<h1>Setup </h1>
<p>The first function to call when your application is launched is <a class="el" href="">CClan::Setup</a>. This will configure the CloudBuilder library for you. This function, as most of the functions from the SDK, exhibits a few concepts: you must pass additional parameters in the form of a <a class="el" href="">CHJSON</a> object and may provide a callback to be notified when the asynchronous process completes. The following code snippet shows the structure that is used by most SDK API calls:</p>
<h2>C++ version </h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyGame</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> Startup()</div>
<div class="line">    {</div>
<div class="line">        CotCHelpers::CHJSON json;</div>
<div class="line">        json.Put(<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;*****&quot;</span>);</div>
<div class="line">        json.Put(<span class="stringliteral">&quot;secret&quot;</span>, <span class="stringliteral">&quot;*****&quot;</span>);</div>
<div class="line">        json.Put(<span class="stringliteral">&quot;env&quot;</span>, <span class="stringliteral">&quot;sandbox&quot;</span>);</div>
<div class="line">        CloudBuilder::CClan::Instance()-&gt;Setup(&amp;json, CloudBuilder::MakeResultHandler(<span class="keyword">this</span>, &amp;MyGame::SetupDone));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> SetupDone(CloudBuilder::eErrorCode errorCode, <span class="keyword">const</span> CloudBuilder::CCloudResult *result)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (errorCode == CloudBuilder::enNoErr)</div>
<div class="line">        {</div>
<div class="line">            printf(<span class="stringliteral">&quot;Setup complete!\n&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            printf(<span class="stringliteral">&quot;Setup failed with message %s!\n&quot;</span>, result-&gt;GetErrorString());</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>First about the <a class="el" href="">CHJSON</a> object. See it as a simple bag of key/values. You will declare one and put the values inside (boolean, integer, floating point, string) using the Put method, passing the key and the value in this order. The lifecycle of the CHJSON object is managed by you, so if you allocated it with new, you need to delete it sometime after having passed it to the SDK.</p>
<p>Then about the <a class="el" href="">CCloudResult</a>. It is a simple object that basically just encapsulates (error) information about the last call as well as the resulting JSON as returned by the server (exposed as a <code>CHJSON</code>), if applicable. You may call <a class="el" href="">GetErrorString</a> during your debugging phase to know what happened. To print out comprehensive information about the result, you may use the <a class="el" href="">Print</a> method as follows:</p>
<div class="fragment"><div class="line">printf(<span class="stringliteral">&quot;Result: %s\n&quot;</span>, std::unique_ptr&lt;char&gt;(result-&gt;Print()));</div>
</div><!-- fragment --><p>Thirdly, let's speak about the delegate system. The structure of a <a class="el" href="">CResultHandler</a> as accepted by all asynchronous calls of the SDK (also known as <code>CDelegate&lt;void (eErrorCode, const CCloudResult)&gt;</code>) represents a C++ method to be called by the SDK, unconditionally, once and only once, along with two arguments. Such a method typically has the form of the <code>MyGame::SetupDone</code> above. You may also pass up to three additional arguments when building it with <a class="el" href="">MakeResultHandler</a>. They will have to be accepted by your function after the two usual ones. The previous example could be transformed this way if you wanted to pass an additional integer value.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyGame</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> Startup()</div>
<div class="line">    {</div>
<div class="line">        CotCHelpers::CHJSON json;</div>
<div class="line">        json.Put(<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;*****&quot;</span>);</div>
<div class="line">        json.Put(<span class="stringliteral">&quot;secret&quot;</span>, <span class="stringliteral">&quot;*****&quot;</span>);</div>
<div class="line">        json.Put(<span class="stringliteral">&quot;env&quot;</span>, <span class="stringliteral">&quot;sandbox&quot;</span>);</div>
<div class="line">        CloudBuilder::CClan::Instance()-&gt;Setup(&amp;json, CloudBuilder::MakeResultHandler(<span class="keyword">this</span>, &amp;MyGame::SetupDone, 12345));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> SetupDone(CloudBuilder::eErrorCode errorCode, <span class="keyword">const</span> CloudBuilder::CCloudResult *result, <span class="keywordtype">int</span> additionalParam)</div>
<div class="line">    {</div>
<div class="line">        printf(<span class="stringliteral">&quot;Setup is done, with parameter %d\n&quot;</span>, additionalParam);      <span class="comment">// 12345</span></div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>If the compiler does not accept the method passed to <a class="el" href="">MakeResultHandler</a>, check that the target type containing the method matches the one of the first parameter, and that the additional parameters passed correspond to the method declaration.</p>
<p>You may also do much more with the delegates, please take a look at the page <a class="el" href="more_advanced.html">More advanced topics</a>.</p>
<h2>Unity/C# version </h2>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>MyGame : MonoBehaviour</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keywordtype">void</span> Start()</div>
<div class="line">    {</div>
<div class="line">        Dictionary&lt;string, object&gt; setupDict = <span class="keyword">new</span> Dictionary&lt;string, object&gt;();</div>
<div class="line">        setupDict[<span class="stringliteral">&quot;key&quot;</span>] = <span class="stringliteral">&quot;*****&quot;</span>;</div>
<div class="line">        setupDict[<span class="stringliteral">&quot;secret&quot;</span>] = <span class="stringliteral">&quot;*****&quot;</span>;</div>
<div class="line">        setupDict[<span class="stringliteral">&quot;env&quot;</span>] = <span class="stringliteral">&quot;sandbox&quot;</span>;</div>
<div class="line"></div>
<div class="line">        CloudBuilderUnity.CClan.Setup(<a class="code" href="namespace_lit_json.html">LitJson</a>.JsonMapper.ToJson(setupDict), delegate(CloudBuilderUnity.eErrorCode aErrorSetup, <span class="keywordtype">string</span> aResultSetup)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span>(aErrorSetup == CloudBuilderUnity.eErrorCode.enNoErr)</div>
<div class="line">            {</div>
<div class="line">                Debug.Log(<span class="stringliteral">&quot;Setup success&quot;</span>);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">                Debug.Log(<span class="stringliteral">&quot;Setup failure: &quot;</span> + aErrorSetup);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>There are a few things which change in the C# version, but all the main concepts remain the same. You can notice that the Setup method is still called Setup, it still belongs to the CClan class, and it still takes a JSON object and delegate as parameters. This will be the case for most classes and methods of the framework, which means that the C++ technical documentation can be used as well for the C# developers. Three differences can be identified:</p><ul>
<li>where we use the CHJSON class in C++, a C# string class will be instead. In our sample, we use the open source LitJson implementation and a C# Dictionary class to generate the correct string. As long as you pass a valid C# string to the framework, you can use whatever C# JSON implementation.</li>
<li>the delegate definition in C# can be directly embedded in the parameter list, as it is the case in this snippet of code.</li>
<li>the second parameter of the delegate in the C++ version is a CCloudResult object, which is mostly a wrapper around the CHJSON class. In C#, we pass directly as a string object, that you just need to parse in order to get the corresponding JSON.</li>
</ul>
<p>Also you can note that our script, which can be attached to a Unity object, derives from MonoBehaviour. By doing this, we ensure that its Start method is called by Unity player when this one runs, hence calling the Setup automatically at runtime. Other Unity/C# snippets of code (see below) belong to overloaded methods which are automatically called by Unity during the lifecycle of the game.</p>
<h1>The CloudBuilder loop </h1>
<p>In the previous example, we have just seen how to parameterize to which games and servers you will connect, and that we will notify you of the success or failure of this request through a handler that you pass to us. How, then, are we able to call your handler? It all comes down to one line of code, that you have to call regularly. In your game loop, you could call the following code for each frame:</p>
<h2>C++ version </h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyGame</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> Update()</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Do all the usual stuff: update world data, process input, check for collisions, ...</span></div>
<div class="line"></div>
<div class="line">        CloudBuilder::CClan::Instance()-&gt;ProcessIdleTasks();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2>Unity/C# version </h2>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>MyGame : MonoBehaviour</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keywordtype">void</span> Update()</div>
<div class="line">    {</div>
<div class="line">        CloudBuilderUnity.CClan.ProcessIdleTasks();</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Just by calling this, you ensure that each time one of your requests has been processed by our servers, we will then call your handler so you can decide what to do depending on the result of your request. Note that this function is a really lightweight process, and that no network operation is involved. It means it can be called at a high frequency, and it will impact neither your CPU charge nor your framerate. It does ensure though, that your requests will be processed with as little latency as possible. This is possible because we do all the hard work for you behind the curtains. We manage threads for you, and this is completely transparent, so you do not need to worry about it. Give us your handler, and we'll call you!</p>
<p>There is another aspect to consider when developing with CloudBuilder framework, which still relates to the game lifecycle. This is especially true of the mobile platforms, but it is also the case on the desktop, and it is about managing background and foreground activity. We need to know if the game is currently running in the foreground, or if the user has pushed it to the background. Why? This is mostly to deal with push notifications, that our framework handles automatically for you. Everytime there is an interaction between two, or more, players, some data are exchanged. By knowing that one or several of the recipients are in the background, we can create a push notification which will remind them they have to check their game because something important happened. It is very easy to setup and you can configure these push notifications as you wish by customizing them.</p>
<h2>C++ version </h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyGame</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> GoToBackground()</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Do all the usual stuff: pause renderer and sound engine, ...</span></div>
<div class="line"></div>
<div class="line">        CloudBuilder::CClan::Instance()-&gt;Suspend();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> GoToForeground()</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Do all the usual stuff: resume renderer and sound engine, ...</span></div>
<div class="line"></div>
<div class="line">        CloudBuilder::CClan::Instance()-&gt;Resume();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2>Unity/C# version </h2>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>MyGame : MonoBehaviour</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> OnApplicationPause(<span class="keywordtype">bool</span> aPaused)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span>(aPaused)</div>
<div class="line">            CloudBuilderUnity.CClan.Suspend();</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">            CloudBuilderUnity.CClan.Resume();</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The last thing to handle for the lifecycle of the game is when the user quits the game. Just like when going to the background, we need to know the game process is finished. Not only to know that the framework has to generate push notifications if needed, but also to clean things on the server. It is implemented just like this:</p>
<h2>C++ version </h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyGame</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> Quit()</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Do all the usual stuff: resume renderer and sound engine, ...</span></div>
<div class="line"></div>
<div class="line">        CloudBuilder::CClan::Instance()-&gt;Terminate();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2>Unity/C# version </h2>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>MyGame : MonoBehaviour</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> OnApplicationQuit()</div>
<div class="line">    {</div>
<div class="line">        CloudBuilderUnity.CClan.Terminate ();</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>If this is not done, this is not an issue, since after some time, our servers detect that the client does not answer anymore, and we detach it properly. But it is always better to do it at the right time, to ensure consistency.</p>
<h1>Next step: logging into CloudBuilder as a player </h1>
<p>Right! Now we have seen how to setup CloudBuilder, how we communicate with you, the developer, through handlers you give us, and finally we now know how the game and our framework should interact together in order for smooth operations between your games and our servers. So let's go a bit further in the development and let's look at the next step, the mandatory one before being able to invoke any of our features: logging in as a player. There are several ways to create an account with our framework. The easiest one is to use the concept of "Anonymous login", because it does not involve any interaction with the player, and no UI is necessary. This login silently creates a new user who will then be able to make requests to our servers. A bit of code is always good to look at! Here it is, it can not be simpler...</p>
<h2>C++ version </h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyGame</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> CreateAnonymousLogin()</div>
<div class="line">    {</div>
<div class="line">        CloudBuilder::CUserManager::Instance()-&gt;LoginAnonymous(MakeResultHandler(<span class="keyword">this</span>, &amp;MyGame::LoginHandler));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> LoginHandler(eErrorCode aErrorCode, <span class="keyword">const</span> CloudBuilder::CCloudResult *aResult)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//  If anonymous account creation went well, then we can dive in the data returned.</span></div>
<div class="line">        <span class="keywordflow">if</span>(aErrorCode == eErrorCode::enNoErr)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">//  From the result, we get the embedded JSON, which could be displayed with a call to result-&gt;printFormatted();</span></div>
<div class="line">            <span class="keyword">const</span> CHJSON* json = aResult-&gt;GetJSON();</div>
<div class="line"></div>
<div class="line">            <span class="comment">//  Inside this JSON, we have lots of data that you can browse, for example here we&#39;ll grab profile and credentials.</span></div>
<div class="line">            std::string <span class="keywordtype">id</span> = json-&gt;GetString(<span class="stringliteral">&quot;gamer_id&quot;</span>);</div>
<div class="line">            std::string secret = json-&gt;GetString(<span class="stringliteral">&quot;gamer_secret&quot;</span>);</div>
<div class="line"></div>
<div class="line">            <span class="keyword">const</span> CHJSON* profile = json-&gt;Get(<span class="stringliteral">&quot;profile&quot;</span>);</div>
<div class="line">            std::string name = profile-&gt;GetString(<span class="stringliteral">&quot;displayName&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">            printf(<span class="stringliteral">&quot;Could not login due to error: %d - %s\n&quot;</span>, aErrorCode, aResult-&gt;GetErrorString());</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2>Unity/C# version </h2>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>MyGame : MonoBehaviour</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> CreateAnonymousLogin()</div>
<div class="line">    {</div>
<div class="line">        CloudBuilderUnity.CUser.LoginAnonymous(delegate(CloudBuilderUnity.eErrorCode aErrorLogin, <span class="keywordtype">string</span> aResultLogin) {</div>
<div class="line">            if(aErrorLogin == CloudBuilderUnity.eErrorCode.enNoErr)</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">//  From the result, we get the serialized JSON;</span></div>
<div class="line">                LitJson.JsonData json = LitJson.JsonMapper.ToObject(aResultLogin);</div>
<div class="line"></div>
<div class="line">                <span class="comment">//  Inside this JSON, we have lots of data that you can browse, for example here we&#39;ll grab profile and credentials.</span></div>
<div class="line">                string id = (string) json[<span class="stringliteral">&quot;gamer_id&quot;</span>];</div>
<div class="line">                string secret = (string) json[<span class="stringliteral">&quot;gamer_secret&quot;</span>];</div>
<div class="line"></div>
<div class="line">                LitJson.JsonData profile = json[<span class="stringliteral">&quot;profile&quot;</span>];</div>
<div class="line">                string name = (string) profile[<span class="stringliteral">&quot;displayName&quot;</span>];</div>
<div class="line"></div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">                Debug.Log(<span class="stringliteral">&quot;Could not login due to error: &quot;</span> + aErrorLogin  + <span class="stringliteral">&quot; - &quot;</span> + aResultLogin);</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">}</div>
</div><!-- fragment --><p>You can see we have kept two strings holding the credentials, id and secret, of the newly created account. This way, you can store them locally on the device, and the next time the game will run, you will be able to see that an anonymous account has already been created. This means you do not need to call LoginAnonymous again, but you can simply resume the session for this user, with the code below. Note that the handler could be different, but it could also be the same, since our servers will return the same data for both calls.</p>
<h2>C++ version </h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyGame</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> ResumeSession()</div>
<div class="line">    {</div>
<div class="line">        CHJSON json;</div>
<div class="line">        json.Put(<span class="stringliteral">&quot;id&quot;</span>, <span class="stringliteral">&quot;xxxxxxxxxxxxx&quot;</span>);    <span class="comment">//  xxxxxxxxxxxxx is the id string retrieved earlier.</span></div>
<div class="line">        json.Put(<span class="stringliteral">&quot;secret&quot;</span>, <span class="stringliteral">&quot;yyyyyyyyyyyyy&quot;</span>);    <span class="comment">//  yyyyyyyyyyyyy is the secret string retrieved earlier.</span></div>
<div class="line">        json.Put(<span class="stringliteral">&quot;env&quot;</span>, <span class="stringliteral">&quot;sandbox&quot;</span>);</div>
<div class="line">        CloudBuilder::CUserManager::Instance()-&gt;ResumeSession(&amp;json, MakeResultHandler(<span class="keyword">this</span>, &amp;MyGame::LoginHandler));</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2>Unity/C# version </h2>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>MyGame : MonoBehaviour</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> ResumeSession()</div>
<div class="line">    {</div>
<div class="line">        Dictionary&lt;string, object&gt; loginDict = <span class="keyword">new</span> Dictionary&lt;string, object&gt;();</div>
<div class="line">        loginDict[<span class="stringliteral">&quot;id&quot;</span>] = <span class="stringliteral">&quot;xxxxxxxxxxxxx&quot;</span>); <span class="comment">//  xxxxxxxxxxxxx is the id string retrieved earlier.</span></div>
<div class="line">        loginDict[<span class="stringliteral">&quot;secret&quot;</span>] = <span class="stringliteral">&quot;yyyyyyyyyyyyy&quot;</span>); <span class="comment">//  yyyyyyyyyyyyy is the secret string retrieved earlier.</span></div>
<div class="line">        loginDict[<span class="stringliteral">&quot;env&quot;</span>] = <span class="stringliteral">&quot;sandbox&quot;</span><span class="stringliteral">&quot;&quot;</span></div>
<div class="line"></div>
<div class="line">        CloudBuilderUnity.CUser.ResumeSession(<a class="code" href="namespace_lit_json.html">LitJson</a>.JsonMapper.ToJson(loginDict), ResumeSessionDelegate);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> ResumeSessionDelegate(CloudBuilderUnity.eErrorCode aError, <span class="keywordtype">string</span> aResult)</div>
<div class="line">    {</div>
<div class="line">        Debug.Log(<span class="stringliteral">&quot;Login result is: &quot;</span> + aError);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Any data which had been saved during the first session (more on that in later tutorials), will then again be accessible. Note that in the case of the Unity/C# version, we have defined a standalone method that we pass as the delegate, in contrary to other snippets of code where the delegate is defined directly inside the calling function.</p>
<h1>What now? </h1>
<p>You can continue by taking a look at CloudBuilder::CClan, CloudBuilder::CUserManager and CloudBuilder::CTribeManager, which are the three main classes needed to interact with the SDK. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jun 3 2015 10:46:19 for CloudBuilder Unity by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
