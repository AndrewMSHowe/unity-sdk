<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>CotC SDK Unity: Getting started</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="OutputCustomization.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CotC SDK Unity
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Getting started </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The Unity SDK is available at the following URL: <a href="https://github.com/clanofthecloud/unity-sdk/releases">https://github.com/clanofthecloud/unity-sdk/releases</a>.</p>
<p>We decided to cut it in several parts:</p><ul>
<li><b>The core library</b>, which contains all the core classes and communicates with our servers. It is small, has no dependencies and provides almost all functionality.</li>
<li><b>The facebook integration library</b>. It depends on the facebook SDK for Unity and provides facebook related functionality. The integration library is provided as a separate package.</li>
<li><b>The push notification library</b>, which provides that functionality, currently for Android and iOS.</li>
<li><b>The in-app purchase library</b>, which provides the corresponding functionality, currently for Android and iOS.</li>
</ul>
<p>Packages are distributed separately, although we zipped them together due to their relatively small size. Apart from facebook, they also include all their respective dependencies.</p>
<div class="image">
<img src="importpackage01.png" alt="importpackage01.png"/>
<div class="caption">
Import package screen</div></div>
<p> You can deselect <code>SampleScript.cs</code> and <code>SampleScene.unity</code> if you do not need the sample code. After having imported the package, you just need to configure the SDK settings. For that, open the SampleScene and select the Clan of the Cloud SDK object. In the inspector, set the appropriate values (API Key and API Secret) as configured in the backoffice.</p>
<p>Note: if you want to start from zero, you may simply add a new scene and drag &amp; drop the <code>Clan of the Cloud SDK</code> prefab object from the <code>CotC/Prefabs</code> folder into your scene. This object needs to be placed on any scene where you want to use Clan of the Cloud functionality.</p>
<p>Note: if you include any package which provides additional functionality, you need to proceed to its configuration prior to the first compilation. For instance, if you are importing the facebook related package, you will need to import the facebook package as described in the <a href="#facebook_ref">Facebook</a> section. Importing only the core package is the best way to quickly test SDK functionality in your project.</p>
<div class="image">
<img src="importpackage02.png" alt="importpackage02.png"/>
<div class="caption">
Import package screen</div></div>
 <h1><a class="anchor" id="cotcgameobject_ref"></a>
Usage</h1>
<p>Basic usage is provided by the Clan of the Cloud SDK prefab object. You just have to put it on your scene and invoke the GetCloud method on it to fetch a <a class="el" href="class_cotc_sdk_1_1_cloud.html" title="Root class of the SDK. It is stateless and allows to perform basic operations with the SDK...">CotcSdk.Cloud</a> object allowing to use most features. For that, you may simply use <a href="http://docs.unity3d.com/ScriptReference/Object.FindObjectOfType.html">FindObjectOfType&lt;CotcGameObject&gt;</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="namespace_cotc_sdk.html">CotcSdk</a>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>MyGameObject: MonoBehaviour {</div>
<div class="line">    <span class="keyword">private</span> Cloud Cloud;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> Startup() {</div>
<div class="line">        var cb = FindObjectOfType&lt;CotcGameObject&gt;();</div>
<div class="line">        cb.GetCloud().<a class="code" href="class_cotc_sdk_1_1_done.html">Done</a>(cloud =&gt; {</div>
<div class="line">            Cloud = cloud;</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>This code will fetch a cloud object. This operation is asynchronous but will usually take only a very small amount of time, since it only waits for the CotcGameObject to be initialized. You should do it at startup as shown above and keep it as a member of your class.</p>
<p>Another very important object is the <a class="el" href="class_cotc_sdk_1_1_gamer.html" title="Important object from the SDK, allowing to perform many operations that depend on a currently logged ...">CotcSdk.Gamer</a> object. This represents a signed in user, and provides all functionality that requires to be logged in. You will obtain it by logging in through the cloud object.</p>
<div class="fragment"><div class="line">Cloud.LoginAnonymously()</div>
<div class="line">.Catch(ex =&gt; {</div>
<div class="line">    Debug.LogError(<span class="stringliteral">&quot;Login failed: &quot;</span> + ex.ToString());</div>
<div class="line">})</div>
<div class="line">.Done(gamer =&gt; {</div>
<div class="line">    Debug.Log(<span class="stringliteral">&quot;Signed in successfully (ID = &quot;</span> + gamer.GamerId + <span class="stringliteral">&quot;)&quot;</span>);   });</div>
<div class="line">});</div>
</div><!-- fragment --><h1><a class="anchor" id="promises_ref"></a>
Promises</h1>
<p>All functions are asynchronous. Due to the current lack of async/await functionality in Unity, we introduced an asynchronous programming pattern borrowed from Javascript, called promises. You can get more info by <a href="https://promisesaplus.com/">clicking here</a>.</p>
<p>Getting used to promises can take a bit of time, but in a nutshell, you may simply use them as an optional callback as shown below.</p>
<div class="fragment"><div class="line"><span class="comment">// Usual callback-based API</span></div>
<div class="line"><span class="keywordtype">void</span> LoginAnonymously(Action&lt;Gamer&gt; onSuccess, Action&lt;Exception&gt; onFailure);</div>
<div class="line">LoginAnonymously(</div>
<div class="line">    onSuccess: result =&gt; { ... }</div>
<div class="line">    onFailure: ex =&gt; { ... }</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Promise based API (CotC)</span></div>
<div class="line">Promise&lt;Gamer&gt; LoginAnonymously();</div>
<div class="line">LoginAnonymously()</div>
<div class="line">    .Then(result =&gt; { ... })</div>
<div class="line">    .Catch(ex =&gt; { ... });</div>
</div><!-- fragment --><p>The basic principle means that any method of the API will return an <a class="el" href="class_cotc_sdk_1_1_promise_3_01_promised_t_01_4.html">Promise&lt;Type&gt; object</a>, which promises to give a result of that type in the future. The <code>Promise</code> object provides a few methods which will help:</p>
<ul>
<li>Do something when the promise resolves (i.e. a result is given as promised),</li>
<li>Do something when the promise is rejected (i.e. the result can not be provided as promised).</li>
</ul>
<p>Let's take an example:</p>
<div class="fragment"><div class="line"><span class="comment">// Example method:</span></div>
<div class="line">Promise&lt;Gamer&gt; LoginAnonymously();</div>
<div class="line"></div>
<div class="line"><span class="comment">// Do the API call. Will launch the login process.</span></div>
<div class="line">Promise&lt;Gamer&gt; gamerPromise = LoginAnonymously();</div>
<div class="line"><span class="comment">// Here, the promise may already have been resolved (login done), though unknown to us.</span></div>
<div class="line"><span class="comment">// We just tell that we have something to do when the promise gets resolved.</span></div>
<div class="line"><span class="comment">// The handler will either be invoked immediately or once logged in.</span></div>
<div class="line">gamerPromise = gamerPromise.Then((Gamer result) =&gt; {</div>
<div class="line">    ...</div>
<div class="line">});</div>
<div class="line"><span class="comment">// The Done (or Then) handlers won&#39;t get called in case the promise is rejected</span></div>
<div class="line"><span class="comment">// (network error...), so we can (and should) provide a Catch block to handle exceptions.</span></div>
<div class="line"><span class="comment">// They will come up asynchronously as well, so the principle is exactly the same.</span></div>
<div class="line">gamerPromise = gamerPromise.Catch((Exception ex) =&gt; {</div>
<div class="line">    ...</div>
<div class="line">});</div>
</div><!-- fragment --><p>Note that the <a class="el" href="class_cotc_sdk_1_1_promise_3_01_promised_t_01_4.html#ae2f094cd9b4f856ef48492a103eefa75">Then</a> and <a class="el" href="class_cotc_sdk_1_1_promise_3_01_promised_t_01_4.html#a183215f1caffafaad82ca3a3aa217a0c">Catch</a> block return a new promise that can itself be linked to another Then/Catch block. However you should provide a Catch block only after all Then blocks or just before a Done block. The <a class="el" href="class_cotc_sdk_1_1_promise_3_01_promised_t_01_4.html#a0060e4253c0b5b54369b67bd0e26d9cf">Done</a> method returns no promise, and just tells that it is the last thing that you will do with the result. If you provide a Then block, you may then:</p>
<ul>
<li>Provide other Then blocks, which will receive the same result (if the lambda provided in the Then block returns an empty result).</li>
<li>Handle the result returned by the next promise (in case the lambda provided in the previous Then block returned another Promise).</li>
</ul>
<p>Let's show an example:</p>
<div class="fragment"><div class="line"><span class="comment">// Chaining Then blocks</span></div>
<div class="line">Cloud.LoginAnonymously()</div>
<div class="line">.Then(gamer =&gt; {</div>
<div class="line">    Debug.Log(<span class="stringliteral">&quot;Signed in successfully (ID = &quot;</span> + gamer.GamerId + <span class="stringliteral">&quot;)&quot;</span>);   });</div>
<div class="line">})</div>
<div class="line">.Then(gamer =&gt; {</div>
<div class="line">    Debug.Log(<span class="stringliteral">&quot;Here again with the same gamer &quot;</span> + gamer.GamerId);</div>
<div class="line">})</div>
<div class="line">.Catch(ex =&gt; {</div>
<div class="line">    Debug.LogError(<span class="stringliteral">&quot;Login failed: &quot;</span> + ex.ToString());</div>
<div class="line">})</div>
<div class="line">.Done();</div>
</div><!-- fragment --><p>Providing a Done block at the end is not mandatory. Doing so will just ensure that the <a class="el" href="class_cotc_sdk_1_1_promise.html#aacac7a3e73453048089ef81153782c15">Unhandled exception handler</a> is called in case you do not provide a Catch block. That is why we prefer the use of Done over Then in our examples: it will prevent errors from being eaten up silently. We recommend that you always provide a Catch block to handle the exceptional behaviour, or end your chain with <code>.Done()</code> as shown above.</p>
<p>But then there is better, let us say that we want to log in the user and then get his profile. We can return another promise from the Then block and provide a Catch block that will be invoked if either of the calls failed.</p>
<div class="fragment"><div class="line"><span class="comment">// Chaining multiple operations</span></div>
<div class="line">Cloud.LoginAnonymously()</div>
<div class="line">.Then(gamer =&gt; {</div>
<div class="line">    Debug.Log(<span class="stringliteral">&quot;Signed in successfully (ID = &quot;</span> + gamer.GamerId + <span class="stringliteral">&quot;)&quot;</span>);   });</div>
<div class="line">    <span class="comment">// Then read the profile</span></div>
<div class="line">    <span class="keywordflow">return</span> gamer.Profile.Get();</div>
<div class="line">})</div>
<div class="line">.Then(profile =&gt; {</div>
<div class="line">    Debug.Log(<span class="stringliteral">&quot;Got user profile: &quot;</span> + profile[<span class="stringliteral">&quot;displayName&quot;</span>]);</div>
<div class="line">    <span class="comment">// Nothing to do next</span></div>
<div class="line">})</div>
<div class="line">.Catch(ex =&gt; {</div>
<div class="line">    Debug.LogError(<span class="stringliteral">&quot;Either login or get profile failed: &quot;</span> + ex.ToString());</div>
<div class="line">});</div>
</div><!-- fragment --><p>Note that the above result could technically be achieved the following way as well:</p>
<div class="fragment"><div class="line"><span class="comment">// Log unhandled exceptions (.Done block without .Catch -- not called if there is any .Then)</span></div>
<div class="line">Promise.UnhandledException += (<span class="keywordtype">object</span> sender, ExceptionEventArgs e) =&gt; {</div>
<div class="line">    Debug.LogError(<span class="stringliteral">&quot;Any operation failed: &quot;</span> + e.Exception.ToString());</div>
<div class="line">};</div>
<div class="line"><span class="comment">// Chaining multiple operations</span></div>
<div class="line">Cloud.LoginAnonymously().Done(gamer =&gt; {</div>
<div class="line">    Debug.Log(<span class="stringliteral">&quot;Signed in successfully (ID = &quot;</span> + gamer.GamerId + <span class="stringliteral">&quot;)&quot;</span>);   });</div>
<div class="line">    <span class="comment">// Then read the profile</span></div>
<div class="line">    gamer.Profile.Get().Done(profile =&gt; {</div>
<div class="line">        Debug.Log(<span class="stringliteral">&quot;Got user profile: &quot;</span> + profile[<span class="stringliteral">&quot;displayName&quot;</span>]);</div>
<div class="line">    });</div>
<div class="line">});</div>
</div><!-- fragment --><p>The exceptions provided by the API in Catch blocks are always of type <code>CotcException</code>. However, note that if an exception happens in one of the Then blocks (e.g. error in your handling code), the exception will be reported to the next Catch block.</p>
<div class="fragment"><div class="line">Cloud.LoginAnonymously()</div>
<div class="line">.Then(gamer =&gt; {</div>
<div class="line">    <span class="keywordflow">throw</span> <span class="keyword">new</span> Exception();</div>
<div class="line">});</div>
<div class="line">.Catch(ex =&gt; {</div>
<div class="line">    <span class="keywordflow">if</span> (ex is CotcException) {</div>
<div class="line">        Debug.LogError(<span class="stringliteral">&quot;API call failed: &quot;</span> + ((CotcException)ex).ErrorCode);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        Debug.LogError(<span class="stringliteral">&quot;Error in my code: &quot;</span> + ex.ToString());</div>
<div class="line">    }</div>
<div class="line">});</div>
</div><!-- fragment --><h1>Network error handlers</h1>
<p>In case a network error happens, the request is not retried by default. But there is a <code>HttpRequestFailedHandler</code> member on Cloud which can be set to an user defined callback. This callback tells what to do with the error (retry it, cancel it). The following code retries any failed request twice, once after 100ms, once after 5s, then aborts it.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> RetryTimes = {100 <span class="comment">/* ms */</span>, 5000 <span class="comment">/* ms */</span>};</div>
<div class="line">cloud.HttpRequestFailedHandler = (HttpRequestFailedEventArgs e) =&gt; {</div>
<div class="line">    <span class="comment">// Store retry count in UserData field (persisted among retries of a given request)</span></div>
<div class="line">    <span class="keywordtype">int</span> retriedCount = e.UserData != null ? (int)e.UserData : 0;</div>
<div class="line">    e.UserData = retriedCount + 1;</div>
<div class="line">    if (retriedAlready &gt;= RetryTimes.Length)</div>
<div class="line">        e.Abort();</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        e.RetryIn(RetryTimes[retriedAlready]);</div>
<div class="line">};</div>
</div><!-- fragment --><p>This should be done at the very startup, after the cloud has been received. The handler is chosen when an HTTP request is built, so if you change it while an HTTP request is running, it will have no effect.</p>
<h1>Bundle</h1>
<p>Some function calls use bundles. They act as a generic, typed dictionary. Read more at <a class="el" href="class_cotc_sdk_1_1_bundle.html" title="The bundle is a main concept of the CotC SDK. It is basically the equivalent of a JSON object...">CotcSdk.Bundle</a>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Sep 9 2015 10:17:54 for CotC SDK Unity by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
