// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections;
using System.Net;
using System.IO;
using System.Text;
using System.Threading;
using System.Collections.Generic;

namespace CloudBuilderLibrary
{
	public class UnityHttpClient: IHttpClient {
		#region IHttpClient implementation
		void IHttpClient.Run(HttpRequest request) {
			EnqueueRequest(request);
        }

		bool IHttpClient.VerboseMode {
			get { return verboseMode; }
			set { verboseMode = value; }
		}
		#endregion

		#region Private
		/**
		 * Asynchronous request state.
		 */
		private class RequestState {
			// This class stores the State of the request.
			public const int BufferSize = 1024;
			public StringBuilder requestData;
			public byte[] BufferRead;
			public HttpRequest originalRequest;
			public HttpWebRequest request;
			public HttpWebResponse response;
			public Stream streamResponse;
			public RequestState(HttpRequest originalReq, HttpWebRequest req) {
				BufferRead = new byte[BufferSize];
				originalRequest = originalReq;
				requestData = new StringBuilder("");
				request = req;
				streamResponse = null;
			}
		}

		/** Enqueues a request to make it processed asynchronously. Will potentially wait for the other requests enqueued to finish. */
		private void EnqueueRequest(HttpRequest req) {
			lock (this) {
				// Need to enqueue process?
				if (isProcessingRequest) {
					pendingRequests.Add(req);
					return;
				}
			}
			// Or start immediately
			ProcessRequest(req);
		}

		/** Got a network stream to write to. */
		private void GetRequestStreamCallback(IAsyncResult asynchronousResult) {
			CloudBuilder.LogTime("Has request stream");
            RequestState state = asynchronousResult.AsyncState as RequestState;
			try {
                // End the operation
				Stream postStream = state.request.EndGetRequestStream(asynchronousResult);
				// Convert the string into a byte array. 
				byte[] byteArray = Encoding.UTF8.GetBytes(state.originalRequest.BodyString);
				// Write to the request stream.
				postStream.Write(byteArray, 0, byteArray.Length);
				CloudBuilder.LogTime("Will write to stream");
				postStream.Close();
				CloudBuilder.LogTime("Asking for response");
				// Start the asynchronous operation to get the response
	            IAsyncResult result = state.request.BeginGetResponse(new AsyncCallback(RespCallback), state);
			}
			catch (WebException e) {
				CloudBuilder.Log(LogLevel.Warning, "Failed to send data: " + e.Message + ", status=" + e.Status);
				state.originalRequest.Callback(null, e);
            }
        }
        
        /** Logs the current request */
        private void LogRequest(HttpRequest originalReq, HttpWebRequest request) {
			if (!verboseMode) { return; }

			StringBuilder sb = new StringBuilder();
			sb.AppendLine("[" + requestCount + "] " + request.Method + "ing on " + request.RequestUri);
			sb.AppendLine("Headers:");
			foreach (string key in request.Headers) {
				sb.AppendLine("\t" + key + ": " + request.Headers[key]);
			}
			if (originalReq.HasBody) {
				sb.AppendLine("Body: " + originalReq.BodyString);
			}
			CloudBuilder.Log(sb.ToString());
		}

		/** Logs the response */
		private void LogResponse(HttpWebRequest req, HttpResponse response) {
			if (!verboseMode) { return; }

			StringBuilder sb = new StringBuilder();
			sb.AppendLine("[" + requestCount + "] " + req.Method + "ed on " + req.RequestUri);
			sb.AppendLine("Recv. headers:");
			foreach (var pair in response.Headers) {
				sb.AppendLine("\t" + pair.Key + ": " + pair.Value);
			}
			if (response.HasBody) {
				sb.AppendLine("Body: " + response.BodyString);
			}
			CloudBuilder.Log(sb.ToString());
		}

		private void ProcessPendingRequestIfAny() {
			HttpRequest req;
			lock (this) {
				if (pendingRequests.Count == 0) {
					return;
				}
				req = pendingRequests[0];
				pendingRequests.RemoveAt(0);
			}
			ProcessRequest(req);
		}

		private void ProcessRequest(HttpRequest request) {
			CloudBuilder.StartLogTime("Starting request");
			// Configure & perform the request
			var encoding = new System.Text.UTF8Encoding();
			HttpWebRequest req = HttpWebRequest.Create(request.Url) as HttpWebRequest;
			requestCount += 1;
			
			// Auto choose HTTP method
			req.Method = request.Method ?? (request.BodyString != null ? "POST" : "GET");
			req.UserAgent = "TEMP-TODO-UA";
			foreach (var pair in request.Headers) {
				req.Headers[pair.Key] = pair.Value;
			}

			RequestState state = new RequestState(request, req);
			allDone.Reset();
            if (request.BodyString != null) {
				CloudBuilder.LogTime("Getting req stream");
				req.BeginGetRequestStream(new AsyncCallback(GetRequestStreamCallback), state);
			}
			else {
				req.BeginGetResponse(new AsyncCallback(RespCallback), state);
			}
			LogRequest(request, req);
			// Setup timeout
			ThreadPool.RegisterWaitForSingleObject(allDone, new WaitOrTimerCallback(TimeoutCallback), req, defaultTimeoutMillis, true);
        }

		/** Called when a response has been received by the HttpWebRequest. */
		private void RespCallback(IAsyncResult asynchronousResult) {  
			RequestState state = asynchronousResult.AsyncState as RequestState;
			try {
				// State of request is asynchronous.
				HttpWebRequest req = state.request;
				state.response = req.EndGetResponse(asynchronousResult) as HttpWebResponse;
				
				// Read the response into a Stream object.
				Stream responseStream = state.response.GetResponseStream();
				state.streamResponse = responseStream;
				
				// Begin the Reading of the contents of the HTML page and print it to the console.
				responseStream.BeginRead(state.BufferRead, 0, RequestState.BufferSize, new AsyncCallback(ReadCallBack), state);
				return;
			}
			catch (WebException e) {
				CloudBuilder.Log(LogLevel.Warning, "Failed to get response: " + e.Message + ", status=" + e.Status);
				state.originalRequest.Callback(null, e);
			}
			if (state.response != null) { state.response.Close(); }
			allDone.Set();
		}

		/** Reads the response buffer little by little. */
		private void ReadCallBack(IAsyncResult asyncResult) {
			RequestState state = asyncResult.AsyncState as RequestState;
			try {
				Stream responseStream = state.streamResponse;
				int read = responseStream.EndRead(asyncResult);
				// Read the HTML page and then print it to the console. 
				if (read > 0) {
					state.requestData.Append(Encoding.UTF8.GetString(state.BufferRead, 0, read));
					responseStream.BeginRead(state.BufferRead, 0, RequestState.BufferSize, new AsyncCallback(ReadCallBack), state);
					return;
				}
				else {
					// Finished reading
					responseStream.Close();

					HttpResponse result = new HttpResponse();
					HttpWebResponse response = state.response;
					result.StatusCode = (int) response.StatusCode;
					foreach (string key in response.Headers) {
						result.Headers[key] = response.Headers[key];
					}
					// Read the body
					result.BodyString = state.requestData.ToString();
					// Logging
					LogResponse(state.request, result);
					state.originalRequest.Callback(result, null);
					CloudBuilder.LogTime("Req done");
				}
			}
			catch (WebException e) {
				CloudBuilder.Log(LogLevel.Warning, "Failed to read response: " + e.Message + ", status=" + e.Status);
				state.originalRequest.Callback(null, e);
			}
			allDone.Set();
		}

		/** Called upon timeout. */
		private static void TimeoutCallback(object state, bool timedOut) { 
			if (timedOut) {
				HttpWebRequest request = state as HttpWebRequest;
				if (request != null) {
					request.Abort();
				}
			}
		}

		// Request processing
		private ManualResetEvent allDone = new ManualResetEvent(false);
		private bool isProcessingRequest = false;
		private List<HttpRequest> pendingRequests = new List<HttpRequest>();
		// Others
		private const int defaultTimeoutMillis = 30 * 1000;
		private bool verboseMode;
		private static int requestCount = 0;
		#endregion
	}
}

